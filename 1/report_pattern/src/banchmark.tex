\section{Тест производительности}
{\itshape В этом разделе измеряется время работы реализованной сортировки подсчётом и сравнивается со стандартной сортировкой C++ (std::sort).}

Для проверки эффективности была проведена серия запусков на входных данных различного размера.
Элементы представляли собой пары \texttt{(ключ, значение)}, где ключ — почтовый индекс, а значение — строка длиной 64 символа.

Сравнение выполнялось между двумя реализациями:

\begin{enumerate}
    \item {\bfseries Собственная реализация сортировки подсчётом} (стабильная).
    \item {\bfseries Стандартная сортировка C++} с компаратором по ключу.
\end{enumerate}

\begin{alltt}
$ ./gen 100000  > test.txt
$ time ./countsort < test.txt > /dev/null
real    0m0.196s
$ time ./stdsort < test.txt > /dev/null
real    0m0.212s

$ ./gen 500000  > test.txt
$ time ./countsort < test.txt > /dev/null
real    0m1.224s
$ time ./stdsort < test.txt > /dev/null
real    0m0.910s

$ ./gen 1000000 > test.txt
$ time ./countsort < test.txt > /dev/null
real    0m2.256s
$ time ./stdsort < test.txt > /dev/null
real    0m2.008s
\end{alltt}

Из результатов видно:

\begin{itemize}
    \item Для небольших массивов (100000 пар) сортировка подсчётом чуть быстрее или
    примерно сопоставима со стандартной сортировкой.
    \item Для среднего размера (500000 пар) стандартная сортировка начинает
    работать быстрее, хотя сортировка подсчётом остаётся линейной по росту
    времени.
    \item Для большого объёма данных (1000000 пар) стандартная сортировка
    опережает сортировку подсчётом, что связано с эффективностью внутренних
    оптимизаций \texttt{std::sort}, особенно при больших диапазонах ключей.
\end{itemize}

\pagebreak