\section{Тест производительности}
В этом разделе измеряется время работы реализованной сортировки подсчётом и сравнивается со стандартной стабильной сортировкой C++ (\texttt{std::stable\_sort}).

Для проверки эффективности была проведена серия запусков на входных данных различного размера.
Элементы представляли собой пары \texttt{(ключ, значение)}, где ключ - почтовый индекс, а значение - строка длиной от 1 до 64 символов.

Сравнение выполнялось между двумя реализациями:

\begin{enumerate}
    \item {\bfseries Собственная реализация сортировки подсчётом} (стабильная).
    \item {\bfseries \texttt{std::stable\_sort}} с компаратором по ключу.
\end{enumerate}

\begin{table}[h!]
    \centering
    \begin{tabular}{|r|r|r|r|r|}
        \hline
        \textbf{Количество пар} & \textbf{CS median, ms} & \textbf{CS avg, ms} & \textbf{STL median, ms} & \textbf{STL avg, ms} \\
        \hline
        10000    & 1    & 2    & 1    & 1    \\
        50000    & 1    & 3    & 6    & 6    \\
        100000   & 8    & 9    & 13   & 13   \\
        500000   & 74   & 75   & 103  & 104  \\
        1000000  & 156  & 159  & 372  & 356  \\
        2000000  & 586  & 564  & 579  & 599  \\
        5000000  & 1005 & 1057 & 1457 & 1458 \\
        10000000 & 2976 & 3505 & 2937 & 3279 \\
        \hline
    \end{tabular}
    \caption{Результаты бенчмарка (5 прогонов на размер): median и average, ms}
\end{table}

Из результатов видно:

\begin{itemize}
    \item На 10000 пар алгоритмы по медиане практически равны (1 ms против 1 ms).
    \item В диапазоне от 50000 до 5000000 пар сортировка подсчётом в основном быстрее.
    \item На 2000000 пар результаты близкие: по медиане немного быстрее \texttt{std::stable\_sort}, по среднему быстрее сортировка подсчётом.
    \item На 10000000 пар \texttt{std::stable\_sort} снова немного быстрее.
\end{itemize}

Такая картина ожидаема. Для сортировки подсчётом время состоит из линейной
части по числу элементов и стоимости обработки диапазона ключей, тогда как
для \texttt{std::stable\_sort} основной вклад даёт сравнение элементов
(\(O(n \log n)\)). Поэтому на средних объёмах данных преимущество линейного
прохода становится заметным. На очень больших объёмах влияние памяти,
кэширования и фоновой нагрузки системы может частично нивелировать это
преимущество, из-за чего результаты алгоритмов снова сближаются.

\pagebreak
